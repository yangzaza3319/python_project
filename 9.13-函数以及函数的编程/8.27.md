## 函数
> 在 Python中，函数是一段组织好的、可以重复使用的代码，用于执行特定的任务
函数可以接受输入（参数），也可以返回输出（返回值）
使用函数可以帮助我们组织代码。提高可读性和重用性

## python函数式编程

### 函数定义
在python中，函数的定义使用 `def` 关键字，后面跟函数名和参数列表；函数体由缩进的代码块组成
#### 语法
`
def function_name(parameters):
    "函数的文档字符串（可能没有）"
    # 函数体
    # 执行任务的代码
`

#### 函数调用
调用函数时，需要使用函数名后面跟括号，并且加上必要的参数

#### 函数返回值
函数可以使用 `return` 语句拥有返回值；如果没有`return`,则函数默认返回`None`

##### return 关键字
- return 是一个关键字， return 后面的值叫“返回值”
- 不写 return 的情况下，会默认返回一个 None
- 一旦遇到 return，结束整个函数
- 返回多个值会被组织成元组被返回，也可以用多个值来接收
- 使用多个值接收(值的数量必须跟返回值数量对应)

###### 代码示例
```
# 返回值示例代码

# 1. 无返回值的函数（返回None）
def hello():
    print("123456")
result = hello() # 调用函数
print(f"无返回值函数的返回值是{result}")  # 输出：无返回值函数的返回值是None

# 2. 单返回值的函数 
def single_result(n1):
    return n1 ** 2
n2 = 6
square = single_result(n2)
print(f"{n2}的平方是{square}")  # 输出 ：6的平方是36

# 3. 多返回值的函数

def get_user_info():
    name = "张三丰"
    sex = "男"
    age = 80
    city = "武当"
    return name,sex,age,city
user_name,user_sex,user_age = get_user_info()
print(f"用户信息：{user_name},{user_sex},{user_age}岁")
user_info = get_user_info()
print(f"用户信息（元组接收）:{user_info}")


# 条件返回函数
def check_num(num):
    if num > 0 :
        return "正数"
    elif num < 0 :
        return "负数"
    else :
        return "为0"
print(check_num(5))
print(check_num(-2))
print(check_num(0))

```

#### 函数的参数
> 在python中，函数的参数被用于向函数传递输入数据的变量
通过参数，函数可以根据不同的输入执行不同的操作
Python支持多种类型的参数，每种参数类型都有其特定的用途和特点

##### 形参
在函数定义时用来占位置的字符，可以是任何字符，用来表示函数需要有一个参数传递进来
- 形参是指在函数定义时指定的参数，用于接收函数调用时传递的值
- 形参在函数体内作为变量存在，作用域仅限于函数内部
##### 实参
在函数调用时实际传递进去的参数，是一个具体的值，参与函数内部的处理
- 实参是在函数调用时传入的实际值，可以是常量、变量、表达式或其他函数的返回值
- 实参的值被传递给形参

##### 位置参数
位置参数是最常用的参数类型，调用时根据位置传递给函数
参数的数量和顺序必须与函数定义时一致

##### 默认参数
默认参数允许将函数的参数设置为默认值
调用函数时，如果没有提供该函数的值，则使用默认值

##### 关键字参数
按照形参的参数名进行精确传参，使用关键字参数时可以不用考虑形参的具体位置和顺序

##### 动态参数
动态参数是指在函数定义时允许接受可变数量的参数
函数可以处理不同数量的输入，不需要在定义时明确列出所有参数
python提供了两种主要方式实现动态参数：`*args`和`**kwargs`
- `args`允许函数接受任意数量的位置参数，这些参数会被收集到一个元组中
```
def sum_numbers(*args):
    total = sum(args) # args 是一个元组
    return total

```
-  `**kwargs `允许函数接受任意数量的关键字参数，并且这些参数会被收集到一个字典
```
def print_info(**kwargs):
   for key,value in kwargs.items():
      print(f"{key}:{value}") 

print_info(姓名="王多余",年龄=10,城市="西红柿") 
# 输出
    #   姓名:王多余
    #   年龄:10
    #   城市:西红柿
```

##### 函数部分代码示例
```
# 函数的参数

## 形参 实参
def greet01(name):
    print(f"hello,{name}！")
greet01("吴彦祖")  # 输出 hello,吴彦祖！
greet01("刘亦菲")  # 输出 hello,刘亦菲！


## 位置参数

def greet02(name,age):
    print(f"个人信息：1.姓名{name}  2.年龄{age}")
greet02("yc",18)           # 输出 个人信息：1.姓名yc  2.年龄18

## 默认参数、关键字参数、可选参数

def greet03(name,site="https://www.ujs.edu.cn/",address="学府路301号"):
    print(f"site:{site},address:{address}")

greet03(address="解放路438号",name="北固校区",site="www.baidu.com")   # 输出  site:www.baidu.com,address:解放路438号


```

#### 函数部分案例1：简单计算器的实现
```
def calculate(operation, num1 , num2):
    """简单计算器实现"""
    if operation == 'add':
        return num1 + num2
    elif operation == 'subtract':
        return num1 - num2
    elif operation == 'multiply':
        return num1 * num2
    elif operation == 'divide':
        if num2 == 0:
            return "错误：除数不能为零！"
        return num1 / num2
    else:
        return "错误：未知操作！"

# 用户输入
user_operation = input("请输入操作（add, subtract, multiply, divide）: ")
user_num1 = float(input("请输入第一个数字: "))
user_num2 = float(input("请输入第二个数字: "))

# 调用函数
result = calculate(user_operation, user_num1, user_num2)
print(f"结果: {result}")
```

#### 函数案例2：书籍信息管理
```
def add_book(book_title,book_id, *authors, **details):
    """
    添加书籍信息并打印
    """
    print("********************")
    print(f"书籍名称：《{book_title}》")
    print(f"书籍编号：{book_id}")
    print(f"作者：{','.join(authors)}")
    for key, value in details.items():
        print(f"{key}:{value}")
    print("-----")

# 添加书籍
add_book("四世同堂",101,"老舍",备注="1990s",others="小说")
add_book("傅雷家书",102,"傅雷",备注="傅氏家族的育儿观")
add_book("四库全书",103,"明朝人士",备注="一本古代的百科全书")

```

### 命名空间和作用域
> 在python中，命名空间（Namespace）和作用域（Scope）是两个重要的概念，可以帮助我们理解变量的可见性和生命周期

#### 命名空间
命名空间是一个容器，用于存储变量（或者标识符）与对象（值）之间的映射关系。命名空间确保了变量的唯一性，不同的命名空间可以包含相同的变量而不会产生冲突

##### 类型
1. 内置命名空间
 包含python的内置函数和对象，如`len()`、`print()`等
2. 全局命名空间
模块级别的命名空间，包含模块中定义的变量和函数
3. 局部命名空间
函数内部的命名空间，包含函数内部定义的变量
##### 命名空间例子
```
def my_function():
    x = 10 
    print(x)

print(f"局部x的值是{x}")   # 局部命名空间中声明的x只作用于当前函数
x = 10 
my_function()
print("全局x的值是:",x)    # 全局命名空间中声明的x作用域包含声明之后的所有代码

```

#### 作用域
作用域定义了变量的可访问性或可见性。它决定了程序的某一部分变量可以访问某些变量

##### 类型
1. 局部作用域
函数内部定义的变量，仅在函数内部可见
2. 全局作用域
模块级别定义的变量，在整个模块内可见（这里的模块可以说的是某个python文件）
3. 内置作用域
python内置的名字，始终可见

##### 作用域例子
```
# 作用域例子

def outer_function():
    outer_var = "我是外部变量"      # 在outer_function()函数内部定义的变量，局部作用域，仅在outer_function()函数内部可以使用

    def inner_function():
        inner_var = "我是内部变量"  # 在inner_function()函数内部定义的变量，局部作用域，仅在inner_function()函数内部可以使用
        print(inner_var)           
        print(outer_var)

    inner_function()
    # print(inner_var)   # 运行这行代码会报错：未定义“inner_var”,因为这个变量函数在外部不可见

outer_function()
# print(outer_var)         # 运行这行代码会报错：未定义“outer_var”，因为这个变量函数在外部不可见


```
#### 命名空间和作用域的关系
- 命名空间提供了一个上下文，使得变量名可以在不同的上下文中存在，而不会发生冲突
- 作用域决定了这些命名空间的可见性以及可访问性

#### globals 和 locals方法
> globals()和locals()是两个内置函数，用于访问全局命名空间和当前所在的命名空间

- globals()不管再什么地方，都是访问全局命名空间的变量
- locals()是访问当前(所在命名空间)的变量

```
# globals() 和 locals()方法
x = "全局1" 
y = "全局2" 
print(globals())
print(locals())

"""
输出
 {'__name__': 
 '__main__', '__doc__': None, '__package__':
   None, '__loader__':
 <class '_frozen_importlib.BuiltinImporter'>,
   '__spec__': None, '__annotations__':
   {}, '__builtins__': 
   <module 'builtins' (built-in)>, 'x': 
   '全局1', 'y': '全局2', 'func': <function func at 0x0000026701748A40>}
输出
{'__name__': 
'__main__', '__doc__': None, '__package__':
 None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, 
 '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, 'x':
   '全局1', 'y': '全局2', 'func': <function func at 0x0000026701748A40>}
"""

def func():
    a = "当前1" 
    b = "当前2" 
    print(globals())
    print(locals())

func()
"""
输出
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, 'x': '全局1', 'y': '全局2', 'func': <function func at 0x0000026701ACF1A0>}
{'a': '当前1', 'b': '当前2'}
"""
```

#### globals 和 locals关键字
用于在函数内部声明一个全局变量，从而允许在函数内部对它进行修改
```
def modify_global():
    global x  # 声明 x 为全局变量
    x = 20    # 修改全局变量

modify_global()
print(x)  # 输出: 20
```

- 如果不使用 global，在函数内部直接赋值会创建一个新的局部变量，而不会影响全局变量
"
def try_modify():
    x = 30  # 创建一个局部变量 x，未声明为 global
    print(x)  # 输出: 30

try_modify()
print(x)  # 输出: 20，仍然是全局变量的值
"

- 对可变数据类型（list，dict，set）可以直接引用不用通过 global
```
li = [1,2,3]
dic = {'name':'aaron'}

def change():
    li.append(4)
    dic['age'] = 18
    print(dic)
    print(li)

change()
print(dic)
print(li)
```
- nonlocal 关键字用于在嵌套函数中声明一个变量是外层函数的局部变量。它允许内层函数修改外层函数的变量
> 在局部作用域中，对父级作用域（或者更外层作用域非全局作用域）的变量进行引用和修改，并且引用的哪层，从那层及以下此变量全部发生改变

```
def outer_function():
    x = 10  # 外层函数的局部变量

    def inner_function():
        nonlocal x  # 声明 x 为外层函数的局部变量
        x = 20      # 修改外层函数的变量

    inner_function()
    print(x)  # 输出: 20

outer_function()
### nonlocal 仅在嵌套函数中有效，不能用于声明全局变量。
```